<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LAIKA</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="/vendor/FontLoader.js"></script>
  <script src="/vendor/TextGeometry.js"></script>
  <script src="/vendor/OrbitControls.js"></script>
  <script src="/vendor/three-dxf.js"></script>
  <script src="/vendor/dxf-parser.js"></script>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <header>
    <div class="nav">
      <div class="brand" id="btnHome">
        <div class="brand-mark">L</div>
        <div>
          <div style="font-size:14px; color: var(--muted);">AI 도면 플랫폼</div>
          <div style="font-size:16px;">LAIKA</div>
        </div>
      </div>
      <div class="tabs">
      <div class="tab" data-tab="convert">DWG-DXF 변환</div>
        <div class="tab" data-tab="analyze">AI 도면 분석</div>
        <div class="tab" data-tab="generate">AI 도면 생성</div>
      </div>
      <div class="nav-actions">
        <div class="badge" id="userBadge">게스트 · 비로그인</div>
        <button class="btn ghost" id="btnSignup">회원가입</button>
        <button class="btn ghost" id="btnLogin">로그인</button>
      </div>
    </div>
  </header>

  <main>
    <section id="home" class="active">
      <div class="hero">
        <div class="pill">LAIKA · Intelligent Drawing Automation</div>
        <h1>DWG/DXF 파이프라인을 한 곳에서.<br />업로드·분석·생성을 모두 자동화하세요.</h1>
        <p>DWG ↔ DXF 변환, AI 기반 도면 분석, 도면 생성까지 하나의 워크플로우로 제공합니다. 업로드만 하면 버전 관리와 파싱, 분석 결과 시각화가 이어집니다.</p>
        <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
          <button class="btn primary" data-tab-jump="convert">DWG-DXF 변환 시작</button>
          <button class="btn" data-tab-jump="analyze">AI 도면 분석 보기</button>
          <div class="pill-lock">로그인 시 AI 도면 분석 가능 · 구독 시 AI 도면 생성 활성화</div>
        </div>
      </div>
      <div class="layout" style="margin-top:18px;">
        <div class="card">
          <h3>LAIKA가 하는 일</h3>
          <div class="muted">업로드 → 변환 → 파싱 → 분석 → 생성까지 이어지는 여정을 미리 확인하세요.</div>
          <div style="display:flex; flex-direction:column; gap:12px;">
            <div class="capsule"><span class="pill-success">1</span>DWG ↔ DXF 변환 (odaconverter)</div>
            <div class="capsule"><span class="pill-success">2</span>기본 파싱 (ezdxf) · 엔티티/레이어/블록 DB 적재</div>
            <div class="capsule"><span class="pill-warn">3</span>블록/레이어 역할 지정 · 축선/구조체/도곽 설정</div>
            <div class="capsule"><span class="pill-warn">4</span>AI 분석 실행 · 결과 표/다이아그램 다운로드</div>
            <div class="capsule"><span class="pill-error">5</span>구독 시 AI 도면 생성(Coming soon)</div>
          </div>
        </div>
        <div class="card">
          <h3>접근 권한</h3>
          <div class="muted">페이지별 이용 조건입니다.</div>
          <div style="display:flex; flex-direction:column; gap:10px;">
            <div class="tag"><span class="pill-success">공개</span> DWG-DXF 변환 · 누구나 사용</div>
            <div class="tag"><span class="pill-warn">로그인 필요</span> AI 도면 분석 · 회원만</div>
            <div class="tag"><span class="pill-error">구독 필요</span> AI 도면 생성 · 결제 구독자 전용</div>
          </div>
        </div>
      </div>
    </section>

    <section id="login">
      <div class="hero">
        <div class="pill">로그인</div>
        <h1>다시 만나서 반가워요</h1>
        <p>테스트 계정: admin/admin(관리자, 구독), aaa/aaa(회원), bbb/bbb(회원+구독)</p>
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <span class="capsule">admin / admin · 관리자 · 구독</span>
          <span class="capsule">aaa / aaa · 일반 · 미구독</span>
          <span class="capsule">bbb / bbb · 일반 · 구독</span>
        </div>
      </div>
      <div class="layout">
        <div class="card" style="grid-column: span 2;">
          <h3>로그인 폼</h3>
          <div class="field">
            <label>아이디</label>
            <input class="input" id="loginId" placeholder="아이디" />
          </div>
          <div class="field">
            <label>비밀번호</label>
            <input class="input" id="loginPwd" placeholder="비밀번호" type="password" />
          </div>
          <div class="actions-row">
            <button class="btn primary" id="btnDoLogin">로그인</button>
            <button class="btn" data-tab-jump="signup">회원가입으로 이동</button>
          </div>
        </div>
      </div>
    </section>

    <section id="signup">
      <div class="hero">
        <div class="pill">회원가입</div>
        <h1>새 계정을 만들어보세요</h1>
        <p>회원가입 후 AI 도면 분석을 이용할 수 있습니다. 구독은 로그인 후 "구독하기" 버튼으로 전환하세요.</p>
      </div>
      <div class="layout">
        <div class="card" style="grid-column: span 2;">
          <h3>회원가입 폼</h3>
          <div class="field">
            <label>아이디</label>
            <input class="input" id="signupId" placeholder="아이디" />
          </div>
          <div class="field">
            <label>비밀번호</label>
            <input class="input" id="signupPwd" placeholder="비밀번호" type="password" />
          </div>
          <div class="field">
            <label>비밀번호 확인</label>
            <input class="input" id="signupPwd2" placeholder="비밀번호 확인" type="password" />
          </div>
          <div class="actions-row">
            <button class="btn primary" id="btnDoSignup">가입하기</button>
            <button class="btn" data-tab-jump="login">로그인으로 이동</button>
          </div>
        </div>
      </div>
    </section>

    <section id="convert">
      <div class="hero">
        <div class="pill">STEP 1</div>
        <h1>DWG-DXF 변환기</h1>
        <p>웹에서 바로 DWG ↔ DXF 변환할 수 있습니다.</p>
      </div>
      <div class="layout">
        <div class="card" style="grid-column: span 2;">
          <div class="convert-header">
            <h3>파일 업로드</h3>
            <div class="convert-toggle" id="convertToggle">
              <button class="toggle-btn active" data-mode="dwg2dxf">DWG to DXF</button>
              <button class="toggle-btn" data-mode="dxf2dwg">DXF to DWG</button>
            </div>
          </div>
          <div class="dropzone" id="dropConvert">
            <div class="drop-icon"></div>
            <div style="font-size:17px; font-weight:700;" id="convertDropTitle">파일 선택</div>
            <div class="muted" style="margin-top:6px;" id="convertDropHint">또는 여기로 드롭 (최대 100MB)</div>
            <input type="file" id="inputConvert" accept=".dwg" multiple style="display:none;" />
          </div>
          <div class="file-list" id="convertList" style="display:none;"></div>
          <div class="actions-center">
            <button class="btn primary" id="btnConvertStart" disabled>변환하기 <span class="throbber" aria-hidden="true"></span></button>
            <button class="btn" id="btnConvertDownload" style="display:none;">일괄 다운로드</button>
          </div>
        </div>
      </div>
    </section>

    <section id="analyze">
      <div class="hero">
        <div class="pill">STEP 2</div>
        <h1>AI 도면 분석기</h1>
        <p>AI로 DXF 도면을 분석하세요.</p>
        <div id="analyzeLock" class="pill-lock" style="margin-top:8px;">로그인 시 이용 가능합니다.</div>
      </div>
      <div class="layout">
        <div class="card" style="grid-column: span 2;">
          <h3>파일 업로드</h3>
          <div class="dropzone" id="dropAnalyze">
            <div class="drop-icon"></div>
            <div style="font-size:17px; font-weight:700;">파일 선택</div>
            <div class="muted" style="margin-top:6px;">또는 여기로 드롭 (최대 100MB)</div>
            <input type="file" id="inputAnalyze" accept=".dxf" multiple style="display:none;" />
          </div>
          <div class="file-list" id="analyzeList" style="display:none;"></div>
          <div class="actions-center">
            <button class="btn primary" id="btnParse">파싱하기 <span class="throbber" aria-hidden="true"></span></button>
          </div>
        </div>
      </div>
        <div id="resultSection" class="layout" style="margin-top:16px; display:none;">
          <div class="card" style="grid-column: span 2;">
            <h3>파싱 결과</h3>
            <div class="tab-layout" style="margin-top:8px;">
              <div class="tab-rail" id="resultList"></div>
              <div class="card" style="padding:12px; background: var(--surface-2);">
                <div id="resultView" class="muted">파일을 선택하세요.</div>
              </div>
            </div>
            <div class="actions-row" style="margin-top:12px; justify-content:center;">
              <button class="btn primary" id="btnShowDetail">설정하기</button>
            </div>
          </div>
        </div>
      <div id="detailSection" class="layout" style="margin-top:16px; display:none;">
        <div class="card" style="grid-column: span 2;">
          <h3>세부 설정</h3>
          <div class="muted">템플릿 DXF를 선택하면 자동 지정 후 필요 시 세부 요소를 수정할 수 있습니다.</div>
          <div class="row-select" style="grid-template-columns: 140px 1fr auto; margin-top:10px;">
            <label>템플릿 DXF</label>
            <div class="smart-select compact-select" id="template-file-select" data-select-type="template"></div>
          </div>
          <div class="config-columns">
            <div class="config-card">
              <h4>기본</h4>
              <div class="row-select compact"><label>도곽</label><div class="smart-select compact-select" id="basic-border-block" data-select-type="block"></div></div>
              <div class="row-select compact"><label>치수</label><div class="smart-select compact-select" id="basic-dim-layer" data-select-type="layer"></div></div>
              <div class="row-select compact"><label>심볼</label><div class="smart-select compact-select" id="basic-symbol-layer" data-select-type="layer"></div></div>
              <div class="row-select compact"><label>텍스트</label><div class="smart-select compact-select" id="basic-text-layer" data-select-type="layer"></div></div>
              <div class="row-select compact"><label>축선</label><div class="smart-select compact-select" id="struct-axis-layer" data-select-type="layer"></div></div>
            </div>
            <div class="config-card">
              <h4>구조 요소</h4>
              <div class="row-select compact"><label>콘크리트 기둥</label><div class="smart-select compact-select" id="struct-ccol-layer" data-select-type="layer"></div></div>
              <div class="row-select compact"><label>철골 기둥</label><div class="smart-select compact-select" id="struct-scol-layer" data-select-type="layer"></div></div>
              <div class="row-select compact"><label>콘크리트 벽체/슬라브</label><div class="smart-select compact-select" id="struct-cwall-layer" data-select-type="layer"></div></div>
            </div>
            <div class="config-card">
              <h4>비구조 요소</h4>
              <div class="row-select compact"><label>비내력 벽체</label><div class="smart-select compact-select" id="non-wall-layer" data-select-type="layer"></div></div>
              <div class="row-select compact"><label>문</label><div class="smart-select compact-select" id="non-door-layer" data-select-type="layer"></div></div>
              <div class="row-select compact"><label>창호</label><div class="smart-select compact-select" id="non-window-layer" data-select-type="layer"></div></div>
              <div class="row-select compact"><label>계단/경사로</label><div class="smart-select compact-select" id="non-stair-layer" data-select-type="layer"></div></div>
              <div class="row-select compact"><label>엘리베이터</label><div class="smart-select compact-select" id="non-elevator-layer" data-select-type="layer"></div></div>
              <div class="row-select compact"><label>가구</label><div class="smart-select compact-select" id="non-furniture-layer" data-select-type="layer"></div></div>
              <div class="row-select compact"><label>마감</label><div class="smart-select compact-select" id="non-finish-layer" data-select-type="layer"></div></div>
            </div>
          </div>
          <div class="actions-center">
            <button class="btn primary" id="btnAnalyze">분석하기 <span class="throbber" aria-hidden="true"></span></button>
          </div>
        </div>
      </div>
      <div id="aiResultSection" class="layout" style="margin-top:16px; display:none;">
        <div class="card" style="grid-column: span 2;">
          <h3>AI 분석 결과</h3>
          <div class="tab-layout" style="margin-top:8px;">
            <div class="tab-rail" id="aiBorderList"></div>
            <div class="card" style="padding:12px; background: var(--surface-2);">
              <div id="aiResultView" class="muted">결과가 준비되면 여기에 표시됩니다.</div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="generate">
      <div class="hero">
        <div class="pill">STEP 3 · AI 도면 생성</div>
        <h1>AI 도면 생성 (준비중)</h1>
        <p>구독 결제 후 사용할 수 있는 기능입니다.</p>
        <div id="generateLock" class="pill-lock" style="margin-top:8px;">구독 결제 시 활성화됩니다.</div>
        <!-- <div class="actions-row" style="margin-top:12px;">
          <button class="btn primary" id="btnSubscribe">구독하기</button>X
          <button class="btn" id="btnNotify">알림받기</button>
        </div> -->
      </div>
    </section>
  </main>

    <script>
    const $ = (id) => document.getElementById(id);
    const API_BASE = window.API_BASE || "http://localhost:8000";

    const state = {
      activeTab: "home",
      loggedIn: false,
      subscribed: false,
      user: null,
      users: [
        { id: "admin", pwd: "admin", role: "admin", subscribed: true },
        { id: "aaa", pwd: "aaa", role: "user", subscribed: false },
        { id: "bbb", pwd: "bbb", role: "user", subscribed: true },
      ],
      projectId: null,
      convertMode: "dwg2dxf",
      convertFiles: [],
      analyzeFiles: [],
      selectedResult: null,
      selectedOptions: {},
      layerOptions: [],
      blockOptions: [],
      templateFile: null,
      aiBorderIndex: 0,
      viewerLib: null,
      viewerLoading: null,
      parserLib: null,
      parserLoading: null,
      fontLoader: null,
      fontLoading: null,
      font: null,
    };

    const statusCopy = {
      ready: "준비",
      uploading: "업로드 중",
      uploaded: "업로드 완료",
      processing: "처리 중",
      converting: "변환 중",
      parsing: "파싱 중",
      done: "완료",
      failed: "실패",
    };

    const formatSize = (bytes) => {
      if (!bytes && bytes !== 0) return "-";
      const units = ["B", "KB", "MB", "GB"];
      const i = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1);
      const val = bytes / 1024 ** i;
      return `${val.toFixed(val >= 10 || i === 0 ? 0 : 1)} ${units[i]}`;
    };

    const api = async (path, opts = {}) => {
      const { method = "GET", body, headers = {} } = opts;
      const config = { method, headers: { ...headers } };
      if (body instanceof FormData) {
        config.body = body;
      } else if (body !== undefined) {
        config.body = JSON.stringify(body);
        config.headers["Content-Type"] = "application/json";
      }
      const res = await fetch(`${API_BASE}${path}`, config);
      if (!res.ok) {
        const msg = await res.text();
        throw new Error(msg || res.statusText || "API 오류");
      }
      const ct = res.headers.get("content-type") || "";
      return ct.includes("application/json") ? res.json() : res.text();
    };

    function setTab(tab) {
      if (tab === "analyze" && !state.loggedIn) {
        alert("AI 도면 분석은 로그인 후 이용 가능합니다.");
        tab = "login";
      }
      if (tab === "generate" && (!state.loggedIn || !state.subscribed)) {
        if (!state.loggedIn) {
          alert("AI 도면 생성은 로그인 후 이용 가능합니다.");
          tab = "login";
        } else {
          alert("AI 도면 생성은 구독 후 이용 가능합니다.");
          tab = "generate";
        }
      }
      state.activeTab = tab;
      document.querySelectorAll(".tab").forEach((el) => el.classList.toggle("active", el.dataset.tab === tab));
      document.querySelectorAll("section").forEach((sec) => sec.classList.toggle("active", sec.id === tab));
      if ($("analyzeLock")) $("analyzeLock").style.display = state.loggedIn ? "none" : "inline-flex";
      if ($("generateLock")) $("generateLock").style.display = state.subscribed ? "none" : "inline-flex";
    }

    function updateUserUI() {
      $("userBadge").textContent = state.loggedIn
        ? `${state.user.id} · ${state.subscribed ? "구독" : "회원"}${state.user.role === "admin" ? " · 관리자" : ""}`
        : "게스트 · 비로그인";
      $("btnLogin").textContent = state.loggedIn ? "로그아웃" : "로그인";
      $("btnSignup").textContent = state.loggedIn ? "계정" : "회원가입";
      if ($("generateLock")) $("generateLock").style.display = state.subscribed ? "none" : "inline-flex";
      if ($("analyzeLock")) $("analyzeLock").style.display = state.loggedIn ? "none" : "inline-flex";
    }

    function doLogout() {
      state.loggedIn = false;
      state.subscribed = false;
      state.user = null;
      updateUserUI();
      setTab("home");
    }

    function doLogin(id, pwd) {
      const found = state.users.find((u) => u.id === id && u.pwd === pwd);
      if (!found) return alert("아이디 또는 비밀번호를 확인하세요.");
      state.loggedIn = true;
      state.user = { ...found };
      state.subscribed = !!found.subscribed;
      updateUserUI();
      setTab("home");
    }

    function doSignup(id, pwd, pwd2) {
      if (!id || !pwd || !pwd2) return alert("모든 항목을 입력하세요.");
      if (pwd !== pwd2) return alert("비밀번호가 일치하지 않습니다.");
      if (state.users.find((u) => u.id === id)) return alert("이미 존재하는 아이디입니다.");
      state.users.push({ id, pwd, role: "user", subscribed: false });
      alert("가입이 완료되었습니다. 로그인해주세요.");
      setTab("login");
    }


    function renderFileList(kind) {
      const listEl = kind === "convert" ? $("convertList") : $("analyzeList");
      const dropEl = kind === "convert" ? $("dropConvert") : $("dropAnalyze");
      const startBtn = kind === "convert" ? $("btnConvertStart") : $("btnParse");
      const downloadBtn = kind === "convert" ? $("btnConvertDownload") : null;
      const files = kind === "convert" ? state.convertFiles : state.analyzeFiles;
      const hasFiles = files.length > 0;
      if (dropEl) dropEl.style.display = hasFiles ? "none" : "block";
      if (listEl) listEl.style.display = hasFiles ? "flex" : "none";
      if (startBtn) startBtn.disabled = !hasFiles;
      if (downloadBtn) {
        const anyDone = files.some((f) => f.status === "done" && f.pathDxf);
        downloadBtn.style.display = anyDone ? "inline-flex" : "none";
        downloadBtn.disabled = !anyDone;
      }
      if (!hasFiles || !listEl) return;
      listEl.innerHTML = "";
      files.forEach((file, idx) => {
        const row = document.createElement("div");
        row.className = "file-row";
        const canDownload = file.status === "done" && file.pathDxf && kind === "convert";
        row.innerHTML = `
          <div class="file-name">${file.name}</div>
          <div class="muted">${formatSize(file.size)}</div>
          <div class="status-pill ${file.status}">${file.statusLabel || statusCopy[file.status] || "-"}</div>
          <div class="progress"><div class="progress-bar" style="width:${file.progress || 0}%;"></div></div>
          <div class="file-log">${file.log || ""}</div>
          ${
            canDownload
              ? `<button class="btn" data-action="download" title="다운로드">다운로드</button>`
              : `<button class="btn ghost" data-action="remove" title="삭제">✕</button>`
          }
        `;
        row.querySelectorAll("button").forEach((btn) => {
          const action = btn.dataset.action;
          btn.onclick = () => {
            if (action === "download") {
              window.open(`${API_BASE}/convert/${file.fileId}/download?kind=dxf`, "_blank");
              return;
            }
            (kind === "convert" ? state.convertFiles : state.analyzeFiles).splice(idx, 1);
            renderFileList(kind);
          };
        });
        listEl.appendChild(row);
      });
      const addCard = document.createElement("div");
      addCard.className = "add-card";
      addCard.textContent = "+ 파일 추가";
      addCard.onclick = () => (kind === "convert" ? $("inputConvert") : $("inputAnalyze")).click();
      listEl.appendChild(addCard);
    }

      function addFiles(kind, fileList) {
        const allow =
          kind === "convert"
            ? state.convertMode === "dxf2dwg"
              ? [".dxf"]
              : [".dwg"]
            : [".dxf"];
        const target = kind === "convert" ? state.convertFiles : state.analyzeFiles;
        Array.from(fileList).forEach((f) => {
        const ext = `.${(f.name.split(".").pop() || "").toLowerCase()}`;
        if (!allow.includes(ext)) {
          alert(`${allow.join(", ")} 확장자만 업로드할 수 있습니다.`);
          return;
        }
        target.push({
          kind,
          convertMode: kind === "convert" ? state.convertMode : null,
          fileObj: f,
          name: f.name,
          size: f.size,
          status: "ready",
          statusLabel: statusCopy.ready,
          progress: 0,
          log: "대기 중",
          fileId: null,
          pathDxf: null,
          parsedData: null,
          });
        });
        renderFileList(kind);
        if (kind === "analyze" && !state.templateFile && target.length > 0) {
          state.templateFile = target[0];
          state.selectedResult = target[0];
          state.selectedOptions["template-file-select"] = [target[0].name];
          initSmartSelects();
        }
      }

      function bindDropzone(el, kind) {
      ["dragenter", "dragover"].forEach((evt) =>
        el.addEventListener(evt, (e) => {
          e.preventDefault();
          el.classList.add("dragover");
        })
      );
      ["dragleave", "drop"].forEach((evt) =>
        el.addEventListener(evt, (e) => {
          e.preventDefault();
          el.classList.remove("dragover");
        })
      );
      el.addEventListener("drop", (e) => {
        e.preventDefault();
        addFiles(kind, e.dataTransfer.files);
      });
      }

      function updateConvertModeUI() {
        const mode = state.convertMode === "dxf2dwg" ? "dxf2dwg" : "dwg2dxf";
        const input = $("inputConvert");
        const title = $("convertDropTitle");
        const hint = $("convertDropHint");
        const toggle = $("convertToggle");
        if (input) input.accept = mode === "dxf2dwg" ? ".dxf" : ".dwg";
        if (title) title.textContent = mode === "dxf2dwg" ? "DXF 파일 선택" : "DWG 파일 선택";
        if (hint) hint.textContent = mode === "dxf2dwg" ? "DXF → DWG 변환 (최대 100MB)" : "DWG → DXF 변환 (최대 100MB)";
        if (toggle) {
          toggle.querySelectorAll(".toggle-btn").forEach((btn) => {
            btn.classList.toggle("active", btn.dataset.mode === mode);
          });
        }
      }

      function setDetailTab(tab) {
      document.querySelectorAll("[data-detail-tab]").forEach((btn) =>
        btn.classList.toggle("active", btn.dataset.detailTab === tab)
      );
      document.querySelectorAll(".tab-panel").forEach((panel) =>
        panel.classList.toggle("active", panel.id === `panel-${tab}`)
      );
    }

    function initSmartSelects() {
      const closeAll = () => document.querySelectorAll(".smart-select.open").forEach((s) => s.classList.remove("open"));
      document.addEventListener("click", (e) => {
        if (!e.target.closest(".smart-select")) closeAll();
      });
      document.querySelectorAll(".smart-select").forEach((container) => {
        const type = container.dataset.selectType;
        const id = container.id;
        let options = [];
        if (type === "layer") options = state.layerOptions || [];
        else if (type === "block") options = state.blockOptions || [];
        else if (type === "template") options = (state.analyzeFiles || []).map((f) => f.name);
        const selected = new Set(state.selectedOptions[id] || []);
        const placeholder =
          type === "layer"
            ? "레이어를 선택하세요."
            : type === "block"
            ? "블록을 선택하세요."
            : "템플릿을 선택하세요.";
        container.innerHTML = `
          <div class="smart-display"><span class="muted">${placeholder}</span></div>
          <div class="smart-dropdown">
            <input class="smart-search" placeholder="검색..." />
            <div class="smart-list"></div>
          </div>
        `;
        const display = container.querySelector(".smart-display");
        const search = container.querySelector(".smart-search");
        const list = container.querySelector(".smart-list");

        const renderList = (keyword = "") => {
          list.innerHTML = "";
          options
            .filter((opt) => opt.toLowerCase().includes(keyword.toLowerCase()))
            .forEach((opt) => {
              const row = document.createElement("label");
              row.className = "smart-option";
              const input = document.createElement("input");
              input.type = type === "template" ? "radio" : "checkbox";
              input.name = type === "template" ? "template-select" : undefined;
              input.value = opt;
              input.checked = selected.has(opt);
              input.onchange = () => {
                if (type === "template") {
                  selected.clear();
                  if (input.checked) selected.add(opt);
                  const nextTemplate = (state.analyzeFiles || []).find((f) => f.name === opt);
                  if (nextTemplate) {
                    state.templateFile = nextTemplate;
                    state.selectedResult = nextTemplate;
                    loadParsed(nextTemplate).catch(() => {});
                  }
                  state.selectedOptions[id] = Array.from(selected);
                  applyTemplateSelections();
                  closeAll();
                  updateDisplay();
                  return;
                }
                if (input.checked) selected.add(opt);
                else selected.delete(opt);
                state.selectedOptions[id] = Array.from(selected);
                updateDisplay();
              };
              row.appendChild(input);
              row.appendChild(document.createTextNode(opt));
              list.appendChild(row);
            });
        };

        const updateDisplay = () => {
          const arr = Array.from(selected);
          display.textContent =
            arr.length > 0
              ? arr.join(", ")
              : type === "layer"
              ? "레이어를 선택하세요."
              : type === "block"
              ? "블록을 선택하세요."
              : "템플릿을 선택하세요.";
        };

        display.onclick = (e) => {
          e.stopPropagation();
          const isOpen = container.classList.contains("open");
          closeAll();
          if (!isOpen) container.classList.add("open");
        };
        search.oninput = () => renderList(search.value);

        renderList();
        updateDisplay();
      });
    }

    async function uploadOne(file, endpoint) {
      if (file.fileId) return file.fileId;
      file.status = "uploading";
      file.statusLabel = statusCopy.uploading;
      file.progress = 15;
      file.log = "서버로 업로드 중";
      renderFileList(file.kind);
      const fd = new FormData();
      fd.append("file", file.fileObj);
      const resp = await api(endpoint, { method: "POST", body: fd });
      file.fileId = resp.file_id || resp.id || resp.fileId;
      file.status = "uploaded";
      file.statusLabel = statusCopy.uploaded;
      file.progress = 40;
      file.log = "업로드 완료";
      renderFileList(file.kind);
      return file.fileId;
    }

    async function pollStatus(file, mode) {
      return new Promise((resolve) => {
        const loop = async () => {
          try {
            const statusBase = mode === "convert" ? "/convert" : "/parsing";
            const res = await api(`${statusBase}/${file.fileId}/status`);
            const st = (res.status || "").toLowerCase();
            if (st.includes("fail") || st.includes("error")) {
              file.status = "failed";
              file.statusLabel = statusCopy.failed;
              file.progress = 100;
              file.log = res.message || "실패했습니다.";
              renderFileList(file.kind);
              return resolve(false);
            }
            const isDone = st === "done" || st === "completed" || st === "success" || res.path_dxf || res.path_original;
              if (isDone && (mode !== "convert" || res.path_dxf)) {
                file.status = "done";
                file.statusLabel = statusCopy.done;
                file.progress = 100;
                file.log = res.message || "완료되었습니다.";
                file.pathDxf = res.path_dxf || res.upload_path || res.storage_path || file.pathDxf;
                renderFileList(file.kind);
                if (mode === "analyze") {
                  await loadParsed(file).catch(() => {});
                  const allDone = (state.analyzeFiles || []).length > 0 && state.analyzeFiles.every((f) => f.status === "done");
                  if (allDone) {
                    if (!state.templateFile && state.analyzeFiles.length > 0) {
                      state.templateFile = state.analyzeFiles[0];
                    }
                    if (state.templateFile) {
                      await loadParsed(state.templateFile).catch(() => {});
                    }
                    if (!state.selectedResult && state.analyzeFiles.length > 0) {
                      state.selectedResult = state.analyzeFiles[0];
                    }
                    if (state.selectedResult && !state.selectedResult.entitiesTable) {
                      await refreshEntitiesTable(state.selectedResult).catch(() => {});
                    }
                    $("resultSection").style.display = "grid";
                    updateResultList(true);
                    renderResultView();
                  }
                }
                return resolve(true);
              }
            file.status = mode === "convert" ? "processing" : "parsing";
            file.statusLabel = mode === "convert" ? statusCopy.converting : statusCopy.parsing;
            file.progress = mode === "convert" ? 70 : 80;
            file.log = res.message || (mode === "convert" ? "변환 중" : "파싱 중");
            renderFileList(file.kind);
            setTimeout(loop, 1200);
          } catch (err) {
            file.status = "failed";
            file.statusLabel = statusCopy.failed;
            file.progress = 100;
            file.log = err.message || "상태 조회 실패";
            renderFileList(file.kind);
            resolve(false);
          }
        };
        loop();
      });
    }

    async function startConvert() {
        if (state.convertFiles.length === 0) {
          const msg = state.convertMode === "dxf2dwg" ? "업로드할 DXF 파일을 선택하세요." : "업로드할 DWG 파일을 선택하세요.";
          return alert(msg);
        }
        const btn = $("btnConvertStart");
        if (btn) btn.disabled = true;
        if (btn) btn.classList.add("is-loading");
        for (const file of state.convertFiles) {
          try {
            await uploadOne(file, "/convert/upload");
            await api(`/convert/${file.fileId}/convert`, { method: "POST" });
            await pollStatus(file, "convert");
          } catch (err) {
            file.status = "failed";
            file.statusLabel = statusCopy.failed;
            file.log = err.message || "변환 실패";
            renderFileList("convert");
          }
        }
        if (btn) btn.disabled = false;
        if (btn) btn.classList.remove("is-loading");
      }

    function applyTemplateSelections() {
      const layers = state.layerOptions || [];
      const blocks = state.blockOptions || [];
      const findMatches = (arr, keys) =>
        arr.filter((name) => keys.some((k) => (name || "").toUpperCase().includes(k))).map((v) => v);

      const presets = {
        "basic-border-block": { type: "block", keys: ["FORM", "TITLE", "BORD"] },
        "basic-dim-layer": { type: "layer", keys: ["DIM"] },
        "basic-symbol-layer": { type: "layer", keys: ["SYM"] },
        "basic-text-layer": { type: "layer", keys: ["TXT", "TEXT"] },
        "struct-axis-layer": { type: "layer", keys: ["AXIS", "GRID", "CEN"] },
        "struct-ccol-layer": { type: "layer", keys: ["COL"] },
        "struct-scol-layer": { type: "layer", keys: ["STL"] },
        "struct-cwall-layer": { type: "layer", keys: ["CON"] },
        "non-wall-layer": { type: "layer", keys: ["WAL"] },
        "non-door-layer": { type: "layer", keys: ["DOOR"] },
        "non-window-layer": { type: "layer", keys: ["WIN"] },
        "non-stair-layer": { type: "layer", keys: ["STR"] },
        "non-elevator-layer": { type: "layer", keys: ["ELV"] },
        "non-furniture-layer": { type: "layer", keys: ["FURN"] },
        "non-finish-layer": { type: "layer", keys: ["FIN"] },
      };

      Object.entries(presets).forEach(([id, cfg]) => {
        const pool = cfg.type === "layer" ? layers : blocks;
        state.selectedOptions[id] = findMatches(pool, cfg.keys);
      });
      initSmartSelects();
    }

    async function loadEntitiesTable(file) {
      if (!file?.fileId) return;
      const data = await api(`/parsing/${file.fileId}/entities-table`);
      file.entitiesTable = Array.isArray(data.rows) ? data.rows : [];
      file.entitiesTableColumns = Array.isArray(data.columns) ? data.columns : [];
      if (Array.isArray(file.entitiesTable)) {
        const columns = Array.isArray(file.entitiesTableColumns) ? file.entitiesTableColumns : [];
        const handleKey = columns.includes("handle") ? "handle" : "HANDLE";
        const set = new Set();
        file.entitiesTable.forEach((row) => {
          const val = row?.[handleKey];
          if (val) set.add(String(val));
        });
        file.entityHandleCount = set.size || file.entitiesTable.length;
      }
    }

    async function loadParsed(file) {
        if (!file?.fileId) return;
        const data = await api(`/parsing/${file.fileId}/parsed1`);
        file.parsedData = data;
      const layerNames = Array.isArray(data.layers)
        ? data.layers.map((l) => l.name || l.layer || l).filter(Boolean)
        : [];
      const blockNames = Array.isArray(data.blocks)
        ? data.blocks.map((b) => b.name || b.block_name || b).filter(Boolean)
        : [];
      const isTemplate = !state.templateFile || state.templateFile === file;
      if (!state.templateFile) state.templateFile = file;
      if (isTemplate) {
        if (layerNames.length) state.layerOptions = layerNames;
        if (blockNames.length) state.blockOptions = blockNames;
        state.selectedOptions["template-file-select"] = [state.templateFile.name];
        applyTemplateSelections();
      } else if (!state.selectedOptions["template-file-select"] && state.templateFile) {
        state.selectedOptions["template-file-select"] = [state.templateFile.name];
      }
      initSmartSelects();
      updateResultList(true);
      renderResultView();
    }

    async function loadSemanticSummary(file) {
      if (!file?.fileId) return;
      const data = await api(`/parsing/${file.fileId}/semantic-summary`);
      file.semanticSummary = data;
    }

    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    async function refreshSemanticSummary(file, retries = 4) {
      if (!file?.fileId) return;
      for (let i = 0; i <= retries; i++) {
        await loadSemanticSummary(file);
        const summary = file.semanticSummary || {};
        const hasBorder = (summary.border_count || 0) > 0;
        const hasAxis = Array.isArray(summary.axis_summaries) && summary.axis_summaries.length > 0;
        const hasColumns = (summary.column_count || 0) > 0;
        if (hasBorder || hasAxis || hasColumns) return;
        await sleep(800);
      }
    }

    async function refreshEntitiesTable(file, retries = 4) {
      if (!file?.fileId) return;
      for (let i = 0; i <= retries; i++) {
        try {
          await loadEntitiesTable(file);
          if (Array.isArray(file.entitiesTable) && file.entitiesTable.length > 0) return;
        } catch (err) {
          // entities-table 준비 전 404는 잠시 대기 후 재시도
        }
        await sleep(800);
      }
    }

    async function refreshParsedData(file, retries = 4) {
      if (!file?.fileId) return;
      for (let i = 0; i <= retries; i++) {
        try {
          await loadParsed(file);
          const hasTables = !!(file.parsedData && file.parsedData.tables);
          const hasLayers = Array.isArray(file.parsedData?.layers) && file.parsedData.layers.length > 0;
          const hasBlocks = Array.isArray(file.parsedData?.blocks) && file.parsedData.blocks.length > 0;
          if (file.parsedData && (hasTables || hasLayers || hasBlocks)) return;
        } catch (err) {
          // parsed1 준비 전 오류는 잠시 대기 후 재시도
        }
        await sleep(800);
      }
    }

    function renderAiResultView() {
      const view = $("aiResultView");
      const list = $("aiBorderList");
      if (!view) return;
      const file = state.selectedResult || state.analyzeFiles[0];
      if (!file) {
        view.textContent = "분석 결과를 불러오는 중입니다...";
        return;
      }
      const entries = [];
      state.analyzeFiles.forEach((f) => {
        const sum = f.semanticSummary || {};
        const axisItems = Array.isArray(sum.axis_summaries) ? sum.axis_summaries : [];
        const borderItems = Array.isArray(sum.borders) ? sum.borders : [];
        const borderByIndex = new Map();
        borderItems.forEach((item, idx) => {
          const key = item?.border_index || idx + 1;
          borderByIndex.set(key, item);
        });
        if (axisItems.length) {
          axisItems.forEach((item, idx) => {
            const borderIdx = item.border_index || idx + 1;
            entries.push({
              file: f,
              border_index: borderIdx,
              axis_summary: item,
              bbox: item.bbox,
              bbox_world: item.bbox_world,
              border: borderByIndex.get(borderIdx) || null,
            });
          });
        } else if (borderItems.length) {
          borderItems.forEach((item, idx) => {
            entries.push({
              file: f,
              border_index: idx + 1,
              border: item,
              bbox_world: item.bbox_world,
            });
          });
        }
      });
      if (!entries.length) {
        view.textContent = "분석 결과를 불러오는 중입니다...";
        return;
      }
      const selectedIdx = Math.min(Math.max(state.aiBorderIndex || 0, 0), Math.max(entries.length - 1, 0));
      state.aiBorderIndex = selectedIdx;

      const shortenName = (name, max = 22) => {
        if (!name || name.length <= max) return name || "";
        const head = Math.max(6, Math.floor(max * 0.55));
        const tail = Math.max(4, max - head - 3);
        return `${name.slice(0, head)}...${name.slice(name.length - tail)}`;
      };

      if (list) {
        list.innerHTML = "";
        entries.forEach((item, idx) => {
          const btn = document.createElement("button");
          btn.className = "btn ghost";
          if (idx === selectedIdx) btn.classList.add("active");
          const fileLabel = shortenName(item.file?.name || "파일");
          const borderLabel = item.border_index || idx + 1;
          btn.textContent = `${fileLabel} / 도곽 ${borderLabel}`;
          btn.title = `${item.file?.name || "파일"} / 도곽 ${borderLabel}`;
          btn.onclick = () => {
            state.aiBorderIndex = idx;
            renderAiResultView();
          };
          list.appendChild(btn);
        });
      }

      const active = entries[selectedIdx] || {};
      const axisSummary = active.axis_summary || {};
      const xAxes = axisSummary.x_axes || [];
      const yAxes = axisSummary.y_axes || [];
      const xSpacing = axisSummary.x_spacing || [];
      const ySpacing = axisSummary.y_spacing || [];
      const borderBBox =
        active.bbox ||
        active.bbox_world ||
        active.border?.bbox_world ||
        null;
      const activeFile = active.file || file;

      const formatAxisLine = (axes, spacing) => {
        if (!axes.length) return "없음";
        const parts = [];
        axes.forEach((axisItem, idx) => {
          const label = axisItem.label || `X${idx + 1}`;
          parts.push(label);
          if (idx < spacing.length) {
            let dist = spacing[idx];
            if (typeof dist === "number") {
              dist = dist.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }
            parts.push(`←${dist}→`);
          }
        });
        return parts.join("|");
      };

      const activeSummary = activeFile.semanticSummary || {};
      const columnTypes = Array.isArray(activeSummary.column_types) ? activeSummary.column_types : [];
      const columnCount = typeof activeSummary.column_count === "number" ? activeSummary.column_count : 0;
      const columnRows = columnTypes
        .map((col) => {
          const size = col.size || {};
          const sizeLabel =
            size.shape === "circle"
              ? `R ${Number(size.radius || 0).toFixed(2)}`
              : size.shape === "rect"
              ? `${Number(size.width || 0).toFixed(2)} × ${Number(size.height || 0).toFixed(2)}`
              : "-";
          const countLabel = typeof col.count === "number" ? col.count : 0;
          return `<tr><td>${col.type}</td><td>${sizeLabel}</td><td>${countLabel}</td></tr>`;
        })
        .join("");
      view.innerHTML = `
        <div class="card" style="margin-top:10px; background:var(--surface-2);">
          <div id="dxfPreview" class="preview-frame"></div>
        </div>
        <div class="card" style="margin-top:10px; background:var(--surface-2);">
          <div style="font-weight:700;">축선</div>
          <div class="muted" style="margin-top:4px;">X축: ${formatAxisLine(yAxes, ySpacing)}</div>
          <div class="muted">Y축: ${formatAxisLine(xAxes, xSpacing)}</div>
        </div>
        <div class="card" style="margin-top:12px; background:var(--surface-2);">
          <div style="font-weight:700; margin-bottom:6px;">기둥 일람표 (${columnCount}개)</div>
          <table style="width:100%; border-collapse: collapse;">
            <thead>
              <tr>
                <th style="text-align:left; padding:6px 4px; border-bottom:1px solid var(--border);">Type</th>
                <th style="text-align:left; padding:6px 4px; border-bottom:1px solid var(--border);">Size</th>
                <th style="text-align:left; padding:6px 4px; border-bottom:1px solid var(--border);">Count</th>
              </tr>
            </thead>
            <tbody>
              ${columnRows || "<tr><td colspan='3' class='muted' style='padding:6px 4px;'>결과 없음</td></tr>"}
            </tbody>
          </table>
        </div>
      `;
      renderDxfPreview(activeFile, borderBBox);
    }

    async function startParse() {
      if (!state.loggedIn) {
        alert("로그인 후 이용 가능합니다.");
        return setTab("login");
      }
      if (state.analyzeFiles.length === 0) return alert("분석할 DXF 파일을 먼저 업로드하세요.");
      const btn = $("btnParse");
      if (btn) btn.disabled = true;
      if (btn) btn.classList.add("is-loading");
        for (const file of state.analyzeFiles) {
          try {
            await uploadOne(file, "/parsing/upload");
          await api(`/parsing/${file.fileId}/parse1`, { method: "POST" });
          await pollStatus(file, "analyze");
          await refreshParsedData(file).catch(() => {});
          await refreshEntitiesTable(file).catch(() => {});
        } catch (err) {
          file.status = "failed";
          file.statusLabel = statusCopy.failed;
          file.log = err.message || "파싱 실패";
          renderFileList("analyze");
        }
      }
      if (btn) btn.disabled = false;
      if (btn) btn.classList.remove("is-loading");
    }

    function updateResultList(forceSelect = false) {
      const list = $("resultList");
      if (!list) return;
      list.innerHTML = "";
      if (forceSelect && state.analyzeFiles.length > 0 && !state.selectedResult) {
        state.selectedResult = state.analyzeFiles[0];
      }
      if (state.analyzeFiles.length === 0) {
        list.innerHTML = '<div class="muted">파싱된 파일이 없습니다.</div>';
        return;
      }
      state.analyzeFiles.forEach((f) => {
        const btn = document.createElement("button");
        btn.className = "btn ghost";
        if (state.selectedResult === f) btn.classList.add("active");
        btn.textContent = f.name;
        btn.onclick = () => {
          state.selectedResult = f;
          updateResultList();
          if (!f.parsedData && f.fileId) {
            loadParsed(f).catch(() => {});
          }
          if (!f.entitiesTable && f.fileId) {
            refreshEntitiesTable(f)
              .catch(() => {})
              .finally(renderResultView);
          } else {
            renderResultView();
          }
          if ($("aiResultSection") && $("aiResultSection").style.display !== "none") {
            refreshSemanticSummary(f)
              .catch(() => {})
              .finally(renderAiResultView);
          }
        };
        list.appendChild(btn);
      });
    }

    function renderResultView() {
      const view = $("resultView");
      if (!view) return;
      const file = state.selectedResult;
      if (!file) {
        view.innerHTML = '<div class="muted">파싱 결과를 보려면 파일을 선택하세요.</div>';
        return;
      }
      if (!file.parsedData || !file.entitiesTable) {
        if (file.fileId) {
          if (!file._loadingParsed && !file.parsedData) {
            file._loadingParsed = true;
            refreshParsedData(file)
              .catch(() => {})
              .finally(() => {
                file._loadingParsed = false;
                renderResultView();
              });
          }
          if (!file._loadingEntities && !file.entitiesTable) {
            file._loadingEntities = true;
            refreshEntitiesTable(file)
              .catch(() => {})
              .finally(() => {
                file._loadingEntities = false;
                renderResultView();
              });
          }
        }
        view.innerHTML = '<div class="muted">파싱 결과를 불러오는 중입니다...</div>';
        return;
      }
      const data = file.parsedData;
      const counts = data.counts || data.metadata?.counts || {};
        const layers = data.layers || [];
        const blocks = data.blocks || [];
      const totalEntities =
        typeof file.entityHandleCount === "number"
          ? file.entityHandleCount
          : file.entityTableView && Array.isArray(file.entityTableView.rows)
          ? file.entityTableView.rows.length
          : typeof data.total === "number"
          ? data.total
          : Array.isArray(data.entities)
          ? data.entities.length
          : Array.isArray(data.entity_table)
          ? data.entity_table.length
          : 0;
      const totalEntitiesLabel = Number(totalEntities || 0).toLocaleString("en-US");
      const entitiesTable = Array.isArray(file.entitiesTable) ? file.entitiesTable : [];
      const entitiesColumns = Array.isArray(file.entitiesTableColumns) ? file.entitiesTableColumns : [];
      const fallbackRows = data.entities || data.entity_table || [];
      const sourceRows = entitiesTable.length ? entitiesTable : fallbackRows.slice(0, 10);
      const hiddenColumns = new Set(
        [
          "contextData",
          "xScale",
          "yScale",
          "zScale",
          "dimensionType",
          "block",
          "width",
          "lineType",
          "ownerHandle",
          "coordinates",
        ].map((v) => v.toLowerCase())
      );
      const coordColumns = new Set(
        [
          "vertices",
          "startPoint",
          "endPoint",
          "center",
          "position",
          "linearOrAngularPoint1",
          "linearOrAngularPoint2",
        ].map((v) => v.toLowerCase())
      );

      const columns = entitiesColumns.length
        ? entitiesColumns
        : sourceRows.length
        ? Object.keys(sourceRows[0])
        : [];
      const baseColumnsOrdered = ["handle", "type", "layer", "text", "name", "radius", "actualMeasurement"];
      const visibleColumns = ["handle", "type", "layer", "coord_x", "coord_y", "coord_z", "text", "name", "radius", "actualMeasurement"];
      const sortState = file.entitySort || { key: "handle", dir: "asc" };
      const sortable = new Set(["handle", "type", "layer"]);
      file.entitySort = sortState;
      const roundNumbers = (value) => {
        if (typeof value === "number") {
          return Math.round(value * 10000) / 10000;
        }
        if (Array.isArray(value)) {
          return value.map(roundNumbers);
        }
        if (value && typeof value === "object") {
          const out = {};
          Object.keys(value).forEach((k) => {
            out[k] = roundNumbers(value[k]);
          });
          return out;
        }
        return value;
      };
      const formatCoord = (value) => {
        const num = typeof value === "number" ? value : 0;
        return (Math.round(num * 10000) / 10000).toFixed(4);
      };
      const toNumber = (value) => {
        if (typeof value === "number") return value;
        if (typeof value === "string" && value.trim() !== "") {
          const parsed = Number(value);
          return Number.isFinite(parsed) ? parsed : null;
        }
        return null;
      };
      const columnMap = new Map(columns.map((c) => [String(c).toLowerCase(), c]));
      const extractCoordRows = (row) => {
        const out = [];
        coordColumns.forEach((key) => {
          const actualKey = columnMap.get(key) || key;
          const raw = row?.[actualKey];
          if (raw === undefined || raw === null || raw === "") return;
          let value = raw;
          if (typeof raw === "string") {
            const trimmed = raw.trim();
            if (trimmed.startsWith("{") || trimmed.startsWith("[")) {
              try {
                value = JSON.parse(trimmed);
              } catch {
                value = raw;
              }
            }
          }
          const pushPoint = (pt) => {
            if (!pt) return;
            const x = toNumber(pt.x);
            const y = toNumber(pt.y);
            const z = toNumber(pt.z);
            if (x === null && y === null && z === null) return;
            out.push({
              coord_x: formatCoord(x ?? 0),
              coord_y: formatCoord(y ?? 0),
              coord_z: formatCoord(z ?? 0),
            });
          };
          if (Array.isArray(value)) {
            value.forEach((item) => {
              if (item && typeof item === "object") {
                pushPoint(item);
              }
            });
            return;
          }
          if (value && typeof value === "object") {
            pushPoint(value);
          }
        });
        return out;
      };
      const formatCellValue = (value, key) => {
        if (value === undefined || value === null || value === "") return "-";
        const keyLower = String(key || "").toLowerCase();
        if (keyLower === "radius" || keyLower === "actualmeasurement") {
          const num = typeof value === "number" ? value : Number(value);
          if (Number.isFinite(num)) {
            return (Math.round(num * 10000) / 10000).toFixed(4);
          }
        }
        return value;
      };
      const colSpan = Math.max(visibleColumns.length, 1);
      const columnClass = (c) => {
        if (c === "handle") return "col-handle";
        if (c === "type") return "col-type";
        if (c === "layer") return "col-layer";
        if (c === "text") return "col-text";
        if (c === "name") return "col-name";
        if (c === "radius") return "col-radius";
        if (c === "actualMeasurement") return "col-dim";
        if (c.startsWith("coord_")) return "col-coord";
        return "";
      };
      const headerLabel = (c) => (c === "actualMeasurement" ? "dim" : c);
      const headerCells = visibleColumns
        .map((c) => {
          if (!sortable.has(c)) {
            return `<th class="${columnClass(c)}">${headerLabel(c)}</th>`;
          }
          const isActive = sortState.key === c;
          const arrow = isActive ? (sortState.dir === "asc" ? "▲" : "▼") : "▲";
          const arrowClass = isActive ? "sort-arrow" : "sort-arrow muted";
          return `<th class="${columnClass(c)} sortable" data-sort="${c}">${headerLabel(c)}<span class="${arrowClass}">${arrow}</span></th>`;
        })
        .join("");
      const baseColumnSet = new Set(baseColumnsOrdered);
      const csvRows = [];
      const sortKey = sortState.key;
      const sortDir = sortState.dir === "desc" ? -1 : 1;
      const sortedSourceRows = sortKey
        ? [...sourceRows].sort((a, b) => {
            const av = String(a?.[sortKey] ?? "");
            const bv = String(b?.[sortKey] ?? "");
            if (av === bv) return 0;
            return av < bv ? -1 * sortDir : 1 * sortDir;
          })
        : sourceRows;
      const entityRows = sortedSourceRows.flatMap((e) => {
        const coordRows = extractCoordRows(e);
        const rowSpan = coordRows.length || 1;
        const renderRow = (coord, includeBase) =>
          visibleColumns.map((c) => {
            const isCoord = c.startsWith("coord_");
            if (isCoord) {
              const raw = coord ? coord[c] : null;
                return `<td class="${columnClass(c)}">${formatCellValue(raw, c)}</td>`;
            }
            if (!includeBase) {
              return null;
            }
            if (baseColumnSet.has(c) && rowSpan > 1) {
              const raw = e?.[c];
              return `<td class="${columnClass(c)}" rowspan="${rowSpan}">${formatCellValue(raw, c)}</td>`;
            }
            const raw = e?.[c];
            return `<td class="${columnClass(c)}">${formatCellValue(raw, c)}</td>`;
          });
        const renderCsvRow = (coord, includeBase) =>
          visibleColumns.map((c) => {
            const isCoord = c.startsWith("coord_");
            if (isCoord) {
              return formatCellValue(coord ? coord[c] : null, c);
            }
            if (!includeBase) {
              return "";
            }
            return formatCellValue(e?.[c], c);
          });
        if (!coordRows.length) {
          csvRows.push(renderCsvRow(null, true));
          return [`<tr>${renderRow(null, true).filter(Boolean).join("")}</tr>`];
        }
        return coordRows.map((coord, idx) => {
          csvRows.push(renderCsvRow(coord, idx === 0));
          const cells = renderRow(coord, idx === 0).filter(Boolean);
          return `<tr>${cells.join("")}</tr>`;
        });
      });
      file.entityTableView = { columns: visibleColumns, rows: csvRows };

      const tableHtml = `
                <table>
                  <thead><tr>${headerCells}</tr></thead>
                  <tbody>
                    ${entityRows.length ? entityRows.join("") : `<tr><td colspan='${colSpan}'>엔티티 정보 없음</td></tr>`}
                  </tbody>
                </table>
      `;

      if (file._skipPreviewUpdate) {
        const wrap = document.getElementById("entityTableWrap");
        if (wrap) {
          wrap.innerHTML = tableHtml;
          file._skipPreviewUpdate = false;
          document.querySelectorAll("th.sortable[data-sort]").forEach((th) => {
            th.onclick = () => {
              const key = th.dataset.sort;
              const current = file.entitySort || { key: null, dir: "asc" };
              const nextDir = current.key === key && current.dir === "asc" ? "desc" : "asc";
              file.entitySort = { key, dir: nextDir };
              file._skipPreviewUpdate = true;
              renderResultView();
            };
          });
          return;
        }
        file._skipPreviewUpdate = false;
      }

      const layerSource =
        data.tables?.layer?.layers ||
        data.tables?.layers ||
        data.sections?.tables?.layer?.layers ||
        {};
      const layersRows = Object.entries(layerSource).map(([name, info]) => ({
        name,
        colorIndex: info?.colorIndex ?? info?.colorindex ?? info?.color_index ?? "-",
        color: info?.color ?? null,
        visible: info?.visible ?? "-",
        frozen: info?.frozen ?? "-",
      }));
      if (!layersRows.length && Array.isArray(data.layers)) {
        data.layers.forEach((row) => {
          const name = row?.name || row?.layer || row;
          if (name) layersRows.push({ name, colorIndex: "-", visible: "-", frozen: "-" });
        });
      }
      const entityList = Array.isArray(data.entities) ? data.entities : [];
      const blockCounts = entityList.reduce((acc, ent) => {
        const name = ent?.properties?.name || ent?.name;
        const type = ent?.properties?.type || ent?.type;
        if (type === "INSERT" && name) {
          acc[name] = (acc[name] || 0) + 1;
        }
        return acc;
      }, {});
      const blockNames = Array.isArray(data.blocks)
        ? data.blocks.map((b) => b?.name || b?.block_name || b).filter(Boolean)
        : Object.keys(data.sections?.blocks || {});
      const blockRowsSource = blockNames.length ? blockNames : Object.keys(blockCounts);
      const blocksRows = blockRowsSource
        .filter((name) => !String(name).startsWith("*"))
        .map((name) => ({ name, count: blockCounts[name] || 0 }));
      const layerCountLabel = Number(layersRows.length || 0).toLocaleString("en-US");
      const blockCountLabel = Number(blocksRows.length || 0).toLocaleString("en-US");
      const layerSort = file.layerSort || { key: "name", dir: "asc" };
      const blockSort = file.blockSort || { key: "name", dir: "asc" };
      if (!layerSort.key) layerSort.key = "name";
      if (!blockSort.key) blockSort.key = "name";
      file.layerSort = layerSort;
      file.blockSort = blockSort;
      const sortRows = (rows, sortState) => {
        const { key, dir } = sortState || {};
        if (!key) return rows;
        const dirMul = dir === "desc" ? -1 : 1;
        return [...rows].sort((a, b) => {
          const av = a?.[key];
          const bv = b?.[key];
          if (av === bv) return 0;
          return av > bv ? dirMul : -dirMul;
        });
      };
      const colorIndexFallback = (value) => {
        const idx = Number(value);
        if (!Number.isFinite(idx)) return "#999999";
        const map = {
          1: "#ff0000",
          2: "#ffff00",
          3: "#00ff00",
          4: "#00ffff",
          5: "#0000ff",
          6: "#ff00ff",
          7: "#ffffff",
        };
        return map[idx] || "#999999";
      };
      const colorToHex = (value) => {
        if (typeof value === "number" && Number.isFinite(value)) {
          const hex = value.toString(16).padStart(6, "0");
          return `#${hex}`;
        }
        return null;
      };
      const sortedLayers = sortRows(layersRows, layerSort);
      const sortedBlocks = sortRows(blocksRows, blockSort);
      const layerSortArrow = (key) => {
        const active = layerSort.key === key;
        return {
          icon: active ? (layerSort.dir === "asc" ? "▲" : "▼") : "▲",
          cls: active ? "sort-arrow" : "sort-arrow muted",
        };
      };
      const blockSortArrow = (key) => {
        const active = blockSort.key === key;
        return {
          icon: active ? (blockSort.dir === "asc" ? "▲" : "▼") : "▲",
          cls: active ? "sort-arrow" : "sort-arrow muted",
        };
      };

      view.innerHTML = `
        <div class="config-columns" style="margin-top:8px;">
          <div>
            <div style="font-weight:700; margin-bottom:6px;">레이어 TABLE (${layerCountLabel} layers)</div>
            <div class="table-wrap sticky-table" style="max-height:220px;" id="layerTableWrap">
              <table>
                <thead>
                  <tr>
                    <th class="sortable" data-layer-sort="name">layer_name <span class="${layerSortArrow("name").cls}">${layerSortArrow("name").icon}</span></th>
                    <th>colorindex</th>
                    <th>visible</th>
                    <th>frozen</th>
                  </tr>
                </thead>
                <tbody>
                  ${
                    sortedLayers.length
                      ? sortedLayers
                          .map((row) => {
                            const colorHex = colorToHex(row.color) || colorIndexFallback(row.colorIndex);
                            return `<tr><td>${row.name}</td><td><span class="color-swatch" style="background:${colorHex};"></span>${row.colorIndex}</td><td>${row.visible}</td><td>${row.frozen}</td></tr>`;
                          })
                          .join("")
                      : `<tr><td colspan="4">레이어 정보 없음</td></tr>`
                  }
                </tbody>
              </table>
            </div>
          </div>
          <div>
            <div style="font-weight:700; margin-bottom:6px;">블록 TABLE (${blockCountLabel} blocks)</div>
            <div class="table-wrap sticky-table" style="max-height:220px;" id="blockTableWrap">
              <table>
                <thead>
                  <tr>
                    <th class="sortable" data-block-sort="name">block_name <span class="${blockSortArrow("name").cls}">${blockSortArrow("name").icon}</span></th>
                    <th class="sortable" data-block-sort="count">block_cnt <span class="${blockSortArrow("count").cls}">${blockSortArrow("count").icon}</span></th>
                  </tr>
                </thead>
                <tbody>
                  ${
                    sortedBlocks.length
                      ? sortedBlocks
                          .map((row) => `<tr><td>${row.name}</td><td>${row.count}</td></tr>`)
                          .join("")
                      : `<tr><td colspan="2">블록 정보 없음</td></tr>`
                  }
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <div style="margin-top:8px;">
          <div style="font-weight:700; margin:6px 0;">엔티티 TABLE (${totalEntitiesLabel} entities)</div>
          <div class="table-wrap sticky-table" id="entityTableWrap">
            ${tableHtml}
          </div>
            <div class="actions-row" style="margin:8px 0 0; justify-content:flex-end;">
              <button class="btn" onclick="downloadParseJson()">JSON 다운로드</button>
              <button class="btn" onclick="downloadEntitiesCsv()">CSV 다운로드</button>
            </div>
          </div>
        `;

      document.querySelectorAll("[data-layer-sort]").forEach((th) => {
        th.onclick = () => {
          const key = th.dataset.layerSort;
          const current = file.layerSort || { key: "name", dir: "asc" };
          const nextDir = current.key === key && current.dir === "asc" ? "desc" : "asc";
          file.layerSort = { key, dir: nextDir };
          renderResultView();
        };
      });
      document.querySelectorAll("[data-block-sort]").forEach((th) => {
        th.onclick = () => {
          const key = th.dataset.blockSort;
          const current = file.blockSort || { key: "name", dir: "asc" };
          const nextDir = current.key === key && current.dir === "asc" ? "desc" : "asc";
          file.blockSort = { key, dir: nextDir };
          renderResultView();
        };
      });

        document.querySelectorAll("th.sortable[data-sort]").forEach((th) => {
          th.onclick = () => {
            const key = th.dataset.sort;
            const current = file.entitySort || { key: null, dir: "asc" };
            const nextDir = current.key === key && current.dir === "asc" ? "desc" : "asc";
            file.entitySort = { key, dir: nextDir };
            file._skipPreviewUpdate = true;
            renderResultView();
          };
        });

    }

    function downloadEntitiesCsv() {
      const file = state.selectedResult;
      if (!file || !file.entityTableView) {
        alert("엔티티 표를 먼저 표시하세요.");
        return;
      }
      const { columns, rows } = file.entityTableView;
      if (!columns || columns.length === 0) {
        alert("CSV로 내보낼 데이터가 없습니다.");
        return;
      }
      const escapeCsv = (value) => {
        const text = value === undefined || value === null ? "" : String(value);
        if (/[\",\\n]/.test(text)) {
          return `"${text.replace(/\"/g, "\"\"")}"`;
        }
        return text;
      };
      const lines = [];
      lines.push(columns.map(escapeCsv).join(","));
      rows.forEach((row) => {
        lines.push(row.map(escapeCsv).join(","));
      });
      const csvContent = "\ufeff" + lines.join("\n");
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      const base = file.name ? file.name.replace(/\.[^.]+$/, "") : "entities";
      a.download = `${base}_entities.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function downloadParseJson() {
      const file = state.templateFile || state.selectedResult || state.analyzeFiles[0];
      if (!file?.fileId) {
        alert("파싱 결과를 다운로드할 파일을 선택하세요.");
        return;
      }
      window.open(`${API_BASE}/parsing/${file.fileId}/parse1-download`, "_blank");
    }

    function loadScriptOnce(url) {
      return new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = url;
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });
    }

    function ensureFontLoader() {
      if (state.fontLoader) return state.fontLoader;
      if (window.THREE && window.THREE.FontLoader) {
        state.fontLoader = new window.THREE.FontLoader();
      }
      return state.fontLoader;
    }

    async function ensureFont() {
      if (state.font) return state.font;
      const loader = ensureFontLoader();
      if (!loader) return null;
      if (!state.fontLoading) {
        state.fontLoading = new Promise((resolve, reject) => {
          const candidates = [
            "/vendor/NotoSansKR-Regular.typeface.json",
            "/vendor/helvetiker_regular.typeface.json",
          ];
          const tryLoad = (idx) => {
            if (idx >= candidates.length) {
              reject(new Error("font load failed"));
              return;
            }
            loader.load(
              candidates[idx],
              (font) => resolve(font),
              undefined,
              () => tryLoad(idx + 1)
            );
          };
          tryLoad(0);
        });
      }
      try {
        state.font = await state.fontLoading;
      } catch (e) {
        state.font = null;
      }
      return state.font;
    }

    function resolveThreeDxf() {
      return window.ThreeDxf || window.threeDxf || null;
    }

    async function ensureThreeDxf() {
      if (state.viewerLib) return state.viewerLib;
      const existing = resolveThreeDxf();
      if (existing) {
        state.viewerLib = existing;
        return existing;
      }
      const urls = [
        "/vendor/three-dxf.js",
        "https://cdn.jsdelivr.net/npm/three-dxf@1.3.1/dist/three-dxf.js",
      ];
      if (!state.viewerLoading) {
        state.viewerLoading = (async () => {
          for (const url of urls) {
            try {
              await loadScriptOnce(url);
              const lib = resolveThreeDxf();
              if (lib) return lib;
            } catch (err) {
              continue;
            }
          }
          return null;
        })();
      }
      state.viewerLib = await state.viewerLoading;
      return state.viewerLib;
    }

    function resolveDxfParser() {
      const mod = window.DxfParser || window.DXFParser || null;
      if (!mod) return null;
      return mod.default || mod.DxfParser || mod;
    }

    async function ensureDxfParser() {
      if (state.parserLib) return state.parserLib;
      const existing = resolveDxfParser();
      if (existing) {
        state.parserLib = existing;
        return existing;
      }
      const urls = [
        "https://cdn.jsdelivr.net/npm/dxf-parser@1.1.8/dist/dxf-parser.js",
        "https://cdn.jsdelivr.net/npm/dxf-parser@1.1.2/dist/dxf-parser.js",
      ];
      if (!state.parserLoading) {
        state.parserLoading = (async () => {
          for (const url of urls) {
            try {
              await loadScriptOnce(url);
              const ctor = resolveDxfParser();
              if (ctor) return ctor;
            } catch (err) {
              continue;
            }
          }
          return null;
        })();
      }
      state.parserLib = await state.parserLoading;
      return state.parserLib;
    }

    async function renderDxfPreview(file, borderBBox) {
      const container = $("dxfPreview");
      if (!container) return;
      container.innerHTML = "";
      if (!file.fileId) {
        container.innerHTML = '<div class="muted" style="padding:12px;">DXF 파일이 준비되면 미리보기를 표시합니다.</div>';
        return;
      }
      const url = `${API_BASE}/parsing/${file.fileId}/download?kind=dxf`;
      const canvas = document.createElement("div");
      canvas.style.width = "100%";
      canvas.style.height = "100%";
      container.appendChild(canvas);
      const loading = document.createElement("div");
      loading.className = "viewer-loading";
      loading.innerHTML = '<span class="throbber"></span>';
      container.appendChild(loading);
      const threeDxf = await ensureThreeDxf();
      const Parser = await ensureDxfParser();
      const font = await ensureFont();
      if (!threeDxf || !Parser) {
        container.innerHTML =
          '<div class="muted" style="padding:12px;">뷰어/파서 스크립트를 불러오지 못했습니다. <a href="' +
          url +
          '" target="_blank">파일을 다운로드</a> 후 확인하세요.</div>';
        return;
      }

      let text;
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error("DXF 요청 실패");
        text = await res.text();
      } catch (err) {
        container.innerHTML =
          '<div class="muted" style="padding:12px;">DXF 다운로드 실패: ' +
          (err?.message || err?.toString?.() || "알 수 없는 오류") +
          '</div>';
        return;
      }

      let parsed;
      try {
        const parser = new Parser();
        parsed = parser.parseSync(text);
      } catch (err) {
        container.innerHTML =
          '<div class="muted" style="padding:12px;">DXF 파싱 실패: ' +
          (err?.message || err?.toString?.() || "알 수 없는 오류") +
          '</div>';
        return;
      }

      let capturedCamera = null;
      const Ortho = window.THREE?.OrthographicCamera;
      if (Ortho) {
        window.THREE.OrthographicCamera = function (...args) {
          const cam = new Ortho(...args);
          capturedCamera = cam;
          return cam;
        };
        window.THREE.OrthographicCamera.prototype = Ortho.prototype;
      }
      try {
        const width = container.clientWidth || container.offsetWidth || 600;
        const height = container.clientHeight || container.offsetHeight || 340;
        const viewer = new threeDxf.Viewer(parsed, canvas, width, height, font || undefined);
        if (viewer.render) viewer.render();
        if (capturedCamera && borderBBox) {
          const xmin = Number(borderBBox.xmin);
          const ymin = Number(borderBBox.ymin);
          const xmax = Number(borderBBox.xmax);
          const ymax = Number(borderBBox.ymax);
          if ([xmin, ymin, xmax, ymax].every(Number.isFinite)) {
            const pad = 0.05;
            let viewW = Math.max(1, (xmax - xmin) * (1 + pad));
            let viewH = Math.max(1, (ymax - ymin) * (1 + pad));
            const aspect = width / height;
            if (aspect > viewW / viewH) {
              viewW = viewH * aspect;
            } else {
              viewH = viewW / aspect;
            }
            capturedCamera.left = -viewW / 2;
            capturedCamera.right = viewW / 2;
            capturedCamera.top = viewH / 2;
            capturedCamera.bottom = -viewH / 2;
            capturedCamera.position.x = (xmin + xmax) / 2;
            capturedCamera.position.y = (ymin + ymax) / 2;
            capturedCamera.position.z = 10;
            capturedCamera.updateProjectionMatrix();
            capturedCamera.lookAt(capturedCamera.position.x, capturedCamera.position.y, 0);
            if (viewer.render) viewer.render();
          }
        }
        window.addEventListener("resize", () => viewer.resize && viewer.resize(container.clientWidth, container.clientHeight));
        loading.remove();
      } catch (err) {
        container.innerHTML =
          '<div class="muted" style="padding:12px;">뷰어 렌더링 실패: ' +
          (err?.message || err?.toString?.() || "알 수 없는 오류") +
          '</div>';
      } finally {
        if (Ortho) {
          window.THREE.OrthographicCamera = Ortho;
        }
      }
    }

    function bindEvents() {
      document.querySelectorAll(".tab").forEach((tab) => tab.addEventListener("click", () => setTab(tab.dataset.tab)));
      document.querySelectorAll("[data-tab-jump]").forEach((btn) =>
        btn.addEventListener("click", () => setTab(btn.dataset.tabJump))
      );
      $("btnHome").onclick = () => setTab("home");
      $("btnLogin").onclick = () => (state.loggedIn ? doLogout() : setTab("login"));
      $("btnSignup").onclick = () => setTab(state.loggedIn ? "home" : "signup");
      $("btnDoLogin").onclick = () => doLogin($("loginId").value.trim(), $("loginPwd").value);
      ["loginId", "loginPwd"].forEach((id) => {
        const el = $(id);
        if (!el) return;
        el.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            doLogin($("loginId").value.trim(), $("loginPwd").value);
          }
        });
      });
      $("btnDoSignup").onclick = () => doSignup($("signupId").value.trim(), $("signupPwd").value, $("signupPwd2").value);
      const btnSubscribe = $("btnSubscribe");
      if (btnSubscribe) {
        btnSubscribe.onclick = () => {
          if (!state.loggedIn) {
            alert("로그인 후 구독할 수 있습니다.");
            return setTab("login");
          }
          state.subscribed = true;
          if (state.user) state.user.subscribed = true;
          updateUserUI();
          alert("구독이 활성화되었습니다.");
        };
      }
      const btnNotify = $("btnNotify");
      if (btnNotify) btnNotify.onclick = () => alert("준비되면 이메일로 안내해드리겠습니다.");
      $("dropConvert").addEventListener("click", () => $("inputConvert").click());
      $("dropAnalyze").addEventListener("click", () => $("inputAnalyze").click());
      $("inputConvert").addEventListener("change", (e) => addFiles("convert", e.target.files));
      $("inputAnalyze").addEventListener("change", (e) => addFiles("analyze", e.target.files));
      const convertToggle = $("convertToggle");
      if (convertToggle) {
        convertToggle.addEventListener("click", (e) => {
          const btn = e.target.closest(".toggle-btn");
          if (!btn) return;
          const nextMode = btn.dataset.mode;
          if (!nextMode || nextMode === state.convertMode) return;
          if (state.convertFiles.length > 0) {
            const ok = confirm("현재 업로드된 파일이 있습니다. 변환 방향을 바꾸면 목록이 초기화됩니다. 계속할까요?");
            if (!ok) return;
            state.convertFiles = [];
            renderFileList("convert");
          }
          state.convertMode = nextMode;
          updateConvertModeUI();
        });
      }
      bindDropzone($("dropConvert"), "convert");
      bindDropzone($("dropAnalyze"), "analyze");
      $("btnConvertStart").onclick = startConvert;
      $("btnConvertDownload").onclick = async () => {
        const doneFiles = state.convertFiles.filter((f) => f.status === "done" && f.pathDxf);
        if (doneFiles.length === 0) return alert("완료된 파일이 없습니다.");
        const modeSet = new Set(doneFiles.map((f) => f.convertMode || "dwg2dxf"));
        if (modeSet.size > 1) {
          return alert("변환 방향이 섞여 있어 일괄 다운로드가 불가능합니다.");
        }
        const mode = doneFiles[0].convertMode || "dwg2dxf";
        const kind = mode === "dxf2dwg" ? "dwg" : "dxf";
        try {
          const res = await fetch(`${API_BASE}/convert/bulk-download`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ file_ids: doneFiles.map((f) => f.fileId), kind }),
          });
          if (!res.ok) {
            const msg = await res.text();
            throw new Error(msg || "다운로드 실패");
          }
          const blob = await res.blob();
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "dxf_bundle.zip";
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        } catch (e) {
          alert(e.message || "다운로드 중 오류가 발생했습니다.");
        }
      };
      $("btnParse").onclick = startParse;
      const parseDownloadBtn = $("btnParseDownload");
      if (parseDownloadBtn) {
        parseDownloadBtn.onclick = () => {
          const file = state.templateFile || state.selectedResult || state.analyzeFiles[0];
          if (!file?.fileId) return alert("파싱 결과를 다운로드할 파일을 선택하세요.");
          window.open(`${API_BASE}/parsing/${file.fileId}/parse1-download`, "_blank");
        };
      }
      $("btnShowDetail").onclick = () => {
        if (!state.templateFile && state.analyzeFiles.length > 0) {
          state.templateFile = state.analyzeFiles[0];
        }
        if (!state.templateFile) {
          alert("템플릿 DXF를 먼저 선택하세요.");
          return;
        }
        const finalize = () => {
          applyTemplateSelections();
          initSmartSelects();
          $("detailSection").style.display = "grid";
        };
        loadParsed(state.templateFile)
          .catch(() => {})
          .finally(finalize);
      };
      $("btnAnalyze").onclick = async () => {
        if (!state.loggedIn) return alert("로그인 후 이용 가능합니다.");
        if (state.analyzeFiles.length === 0) return alert("분석할 DXF 파일을 먼저 업로드하세요.");
        const doneFiles = state.analyzeFiles.filter((f) => f.status === "done");
        if (doneFiles.length === 0) return alert("파싱 완료된 DXF가 없습니다. 먼저 파싱을 완료하세요.");
        const btn = $("btnAnalyze");
        if (btn) btn.classList.add("is-loading");
        if (!state.selectedResult || !doneFiles.includes(state.selectedResult)) {
          state.selectedResult = doneFiles[0];
        }
        const parse2Payload = { selections: { ...state.selectedOptions } };
        for (const f of doneFiles) {
          try {
            await api(`/parsing/${f.fileId}/parse2`, { method: "POST", body: parse2Payload });
          } catch (err) {
            console.warn("parse2 실패", f.fileId, err);
          }
        }
        for (const f of doneFiles) {
          await refreshSemanticSummary(f).catch(() => {});
        }
        renderAiResultView();
        if (state.selectedResult && !state.selectedResult.parsedData) {
          await loadParsed(state.selectedResult);
        }
        if (state.selectedResult && !state.selectedResult.entitiesTable) {
          await loadEntitiesTable(state.selectedResult);
        }
        $("resultSection").style.display = "grid";
        updateResultList(true);
        renderResultView();
        if ($("aiResultSection")) $("aiResultSection").style.display = "grid";
        if (btn) btn.classList.remove("is-loading");
      };
      document.querySelectorAll("[data-detail-tab]").forEach((btn) =>
        btn.addEventListener("click", () => setDetailTab(btn.dataset.detailTab))
      );
    }

    setTab("home");
    updateUserUI();
    bindEvents();
    updateConvertModeUI();
  </script>
</body>
</html>

